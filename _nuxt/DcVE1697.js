import{u as w,a as N,b as T,g as R,c as J,r as p,d as x,e as F,l as A,f as q,h as Y}from"./D69rub0G.js";import{d as i}from"./Cb9qwsxW.js";import{bR as k}from"./DVsxWjzM.js";function S(t=new Date){const n=t.getFullYear(),g=String(t.getMonth()+1).padStart(2,"0"),c=String(t.getDate()).padStart(2,"0");return`${n}-${g}-${c}`}const $=t=>JSON.parse(JSON.stringify(t)),z=async t=>{await i.habitLogs.add($(t))},O=async(t,n)=>{await i.habitLogs.update(t,$(n))},B=async t=>{const n=await i.habitLogs.where("habitId").equals(t).toArray();return await i.transaction("rw",i.habitLogs,i.routineLogs,async()=>{const g=n.map(c=>c.id);await i.habitLogs.bulkDelete(g);for(const c of n)if(c.asPartOfRoutineLog){const d=await i.routineLogs.get(c.asPartOfRoutineLog);d&&await i.routineLogs.update(d.id,{habitLogIds:d.habitLogIds.filter(L=>L!==c.id)})}}),n},E=t=>JSON.parse(JSON.stringify(t)),C=async t=>await i.routineLogs.get(t),G=async t=>{await i.routineLogs.add(E(t))},H=async(t,n)=>{await i.routineLogs.update(t,E(n))},K=async t=>{await i.transaction("rw",i.routineLogs,async()=>{for(const n of t)if(n.asPartOfRoutineLog){const g=await i.routineLogs.get(n.asPartOfRoutineLog);g&&await i.routineLogs.update(g.id,{habitLogIds:g.habitLogIds.filter(c=>c!==n.id)})}})},P=()=>{const t=w("habit-logs",()=>({})),n=w("habit-logs-loading",()=>!0),g=async()=>{n.value=!0;try{const a=await i.habitLogs.toArray();Object.assign(t.value,Object.fromEntries(a.map(e=>[e.id,e])))}catch(a){console.error("Failed to load habit logs:",a)}finally{n.value=!1}};console.debug("habitLogs init scheduled"),k(async()=>{console.debug("habitLogs init started");try{await g()}catch(a){console.error("habitLogs init error",a)}console.debug("habitLogs init finished")});const c=a=>t.value[a],d=a=>{t.value[a.id]=a},L=a=>{delete t.value[a]};return{habitLogs:t,loadHabitLogs:g,habitLogsLoading:n,get:c,add:d,remove:L,update:(a,e)=>{Object.assign(t.value[a],e)},removeHabitLogsForHabit:a=>{const e=Object.values(t.value).filter(s=>s.habitId===a);for(const s of e)L(s.id);return e}}},D=()=>{const t=w("routine-logs",()=>({})),n=w("routine-logs-loading",()=>!0),g=async()=>{n.value=!0;try{const a=await i.routineLogs.toArray();Object.assign(t.value,Object.fromEntries(a.map(e=>[e.id,e])))}catch(a){console.error("Failed to load RoutineLogs:",a)}finally{n.value=!1}};console.debug("RoutineLogs init scheduled"),k(async()=>{console.debug("RoutineLogs init started");try{await g()}catch(a){console.error("RoutineLogs init error",a)}console.debug("RoutineLogs init finished")});const c=a=>t.value[a],d=a=>{t.value[a.id]=a},L=a=>{delete t.value[a]},h=(a,e)=>{Object.assign(t.value[a],e)};return{routineLogs:t,loadRoutineLogs:g,routineLogsLoading:n,get:c,add:d,remove:L,update:h,removeHabitLogsFromRoutineLogs:a=>{for(const e of a)if(e.asPartOfRoutineLog){const s=c(e.asPartOfRoutineLog);s&&h(s.id,{habitLogIds:s.habitLogIds.filter(o=>o!==e.id)})}}}};let m=null;const _=()=>(m||(m=Q()),m),Q=()=>{const t=N(),n=T(),g=P(),c=D();console.log("creating habit manager");const d=async(o,u,r,l,b=!0,j=[])=>{const v={id:R("habit"),icon:o,title:u,isTracked:b,targetDurationSec:r,targetCompletions:l,linkedRoutines:j,archived:0};try{await J(v),t.addHabit(v)}catch(M){console.error("Failed to add habit:",M)}},L=async o=>{const u=t.getHabit(o);if(u)return u;const r=await Y(o);if(!r)throw new Error(`Habit not found: ${o}`);return t.addHabit(r),r},h=async o=>{const u=await L(o);await i.transaction("rw",i.habits,i.routines,i.habitLogs,i.routineLogs,async()=>{u.linkedRoutines.forEach(async b=>{await p(b,o)}),await x(o);const l=await B(o);K(l)}),u.linkedRoutines.forEach(l=>{n.removeHabitFromRoutine(l,o)}),t.removeHabit(o);const r=g.removeHabitLogsForHabit(o);c.removeHabitLogsFromRoutineLogs(r)},f=async o=>{const u=await L(o);await i.transaction("rw",i.habits,i.routines,async()=>{await F(o,{archived:1});const r=u.linkedRoutines.map(async l=>p(l,o));await Promise.all(r)}),t.updateHabit(o,{archived:1}),u.linkedRoutines.forEach(r=>{n.removeHabitFromRoutine(r,o)})},a=async o=>{await F(o,{archived:0}),t.updateHabit(o,{archived:0})},e=async(o,u)=>{try{await A(o,u),t.linkHabitToRoutine(o,u)}catch(r){console.error("Failed to link habit to routine:",r)}},s=async(o,u)=>{try{await q(o,u),t.unlinkHabitFromRoutine(o,u)}catch(r){console.error("Failed to unlink habit from routine:",r)}};return{habits:t.habits,habitsLoading:t.habitsLoading,addHabit:d,removeHabit:h,archiveHabit:f,unarchiveHabit:a,linkHabitToRoutine:e,unlinkHabitFromRoutine:s}};let y=null;const I=()=>(y||(y=U()),y),U=()=>{const t=D(),n=P(),g=async(a,e=[])=>{let s=R("routinelog");const o={id:s,routineId:a,date:S(),habitLogIds:e};return await G(o),t.add(o),s},c=async a=>{const e=t.get(a);if(e)return e;const s=await C(a);if(!s)throw new Error(`RoutineLog not found: ${a}`);return t.add(s),s},d=async(a,e)=>{await H(a,e),t.update(a,e)},L=async(a,e)=>{const s=t.get(a);if(!s)throw new Error(`RoutineLog not found: ${a}`);await i.transaction("rw",i.routineLogs,i.habitLogs,async()=>{await H(a,{date:e});for(const o of s.habitLogIds)await O(o,{date:e})}),t.update(a,{date:e}),s.habitLogIds.forEach(o=>{n.update(o,{date:e})})},h=async(a,e,s,o,u=S())=>{let r=R("habitlog");const l={id:r,habitId:a,status:e,durationSec:s,asPartOfRoutineLog:o,date:u};let b=null;if(o&&(b=await c(o),!b))throw new Error(`RoutineLog not found: ${o}`);return await i.transaction("rw",i.habitLogs,i.routineLogs,async()=>{await z(l),b&&await H(b.id,{habitLogIds:[...b.habitLogIds,r]})}),n.add(l),b&&t.update(b.id,{habitLogIds:[...b.habitLogIds,r]}),r},f=async(a,e)=>{await O(a,e),n.update(a,e)};return{statsLoading:n.habitLogsLoading&&t.routineLogsLoading,habitLogs:n.habitLogs,routineLogs:t.routineLogs,createRoutineLog:g,getRoutineLog:c,updateRoutineLog:d,updateExecutionDates:L,createHabitLog:h,updateHabitLog:f}};export{I as a,S as g,_ as u};
