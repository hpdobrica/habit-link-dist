import{a as d,g as h}from"./Bi35agSF.js";import{d as o}from"./5hOz_2Hu.js";import{bT as y}from"./C541R0zX.js";function f(s=new Date){const e=s.getFullYear(),r=String(s.getMonth()+1).padStart(2,"0"),u=String(s.getDate()).padStart(2,"0");return`${e}-${r}-${u}`}const v=()=>{const s=d("habit-logs",()=>({})),e=d("routine-logs",()=>({})),r=d("stats-loading",()=>!0),u=async()=>{r.value=!0;try{const c=await o.habitLogs.toArray(),L=await o.routineLogs.toArray();Object.assign(s.value,Object.fromEntries(c.map(g=>[g.id,g]))),Object.assign(e.value,Object.fromEntries(L.map(g=>[g.id,g])))}catch(c){console.error("Failed to load stats:",c)}finally{r.value=!1}};return console.debug("stats init scheduled"),y(async()=>{console.debug("stats init started");try{await u()}catch(c){console.error("stats init error",c)}console.debug("stats init finished")}),{habitLogs:s,routineLogs:e,loadStats:u,statsLoading:r}},O=()=>{const{habitLogs:s,routineLogs:e,loadStats:r,statsLoading:u}=v();return{habitLogs:s,routineLogs:e,statsLoading:u,getRoutineLog:async t=>{if(e.value[t]!==void 0)return e.value[t];const a=await o.routineLogs.get(t);if(a===void 0)throw new Error(`RoutineLog not found: ${t}`);return e.value[t]=a,a},createRoutineLog:async(t,a=[])=>{let i=h("routinelog");const n={id:i,routineId:t,date:f(),habitLogIds:a};return await o.routineLogs.add(n),e.value[i]=n,i},updateRoutineLog:async(t,a)=>{await o.routineLogs.update(t,a),e.value[t]={...e.value[t],...a}},createHabitLog:async(t,a,i,n,p=f())=>{let l=h("habitlog");const b={id:l,habitId:t,status:a,durationSec:i,asPartOfRoutineLog:n,date:p};return o.transaction("rw",o.habitLogs,o.routineLogs,async()=>{n!==null&&await o.routineLogs.where("id").equals(n).modify(w=>{w.habitLogIds.push(l)}),await o.habitLogs.add(b)}),n!==null&&e.value[n].habitLogIds.push(l),s.value[l]=b,l},updateHabitLog:async(t,a)=>{await o.habitLogs.update(t,a),s.value[t]={...s.value[t],...a}},updateExecutionDates:async(t,a)=>{const i=e.value[t];if(i===void 0)throw new Error(`RoutineLog not found: ${t}`);await o.transaction("rw",o.routineLogs,o.habitLogs,async()=>{await o.routineLogs.update(t,{date:a});for(const n of i.habitLogIds)await o.habitLogs.update(n,{date:a})}),e.value[t].date=a,e.value[t].habitLogIds.forEach(n=>{s.value[n].date=a})}}};export{f as g,O as u};
