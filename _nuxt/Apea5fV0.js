import{d as r}from"./BkI_4SxB.js";import{bU as m,p as v,aX as g,bT as h}from"./BDOKz9Zs.js";const y=t=>JSON.parse(JSON.stringify(t)),k=async t=>await r.habits.get(t),S=async t=>{await r.habits.add(y(t))},O=async t=>{await r.habits.delete(t)},F=async(t,a)=>{await r.habits.where("id").equals(t).modify(n=>{n.linkedRoutines.includes(a)||n.linkedRoutines.push(a)})},j=async(t,a)=>{await r.habits.where("id").equals(t).modify(n=>{n.linkedRoutines&&(n.linkedRoutines=y(n.linkedRoutines.filter(s=>s!==a)))})},x=async(t,a)=>{await r.habits.update(t,y(a))},p=t=>JSON.parse(JSON.stringify(t)),I=async t=>await r.routines.get(t),N=async(t,a)=>{await r.routines.update(t,p(a))},$=async t=>{await r.routines.delete(t)},T=async(t,a)=>{await r.routines.where("id").equals(t).modify(n=>{n.habitInstances&&(n.habitInstances=p(n.habitInstances.filter(s=>s.habitId!==a)))})},R="$s";function b(...t){const a=typeof t[t.length-1]=="string"?t.pop():void 0;typeof t[0]!="string"&&t.unshift(a);const[n,s]=t;if(!n||typeof n!="string")throw new TypeError("[nuxt] [useState] key must be a string: "+n);if(s!==void 0&&typeof s!="function")throw new Error("[nuxt] [useState] init must be a function: "+s);const l=R+n,d=m(),u=v(d.payload.state,l);if(u.value===void 0&&s){const c=s();if(g(c))return d.payload.state[l]=c,c;u.value=c}return u}const q=()=>{const t=b("habits",()=>({})),a=b("habits-loading",()=>!0),n=async()=>{a.value=!0;try{const e=await r.habits.toArray();Object.assign(t.value,Object.fromEntries(e.map(o=>[o.id,o])))}catch(e){console.error("Failed to load habits:",e)}finally{a.value=!1}};return h(async()=>{try{await n()}catch(e){console.error("habits init error",e)}}),{habits:t,habitsLoading:a,getHabit:e=>t.value[e],addHabit:e=>{t.value[e.id]=e},removeHabit:e=>{delete t.value[e]},linkHabitToRoutine:(e,o)=>{t.value[e].linkedRoutines.push(o)},unlinkHabitFromRoutine:(e,o)=>{t.value[e].linkedRoutines=t.value[e].linkedRoutines.filter(f=>f!==o)},updateHabit:(e,o)=>{Object.assign(t.value[e],o)}}},A=()=>{const t=b("routines",()=>({})),a=b("routines-loading",()=>!0),n=async()=>{console.log("routines loading"),a.value=!0;try{const i=await r.routines.toArray();Object.assign(t.value,Object.fromEntries(i.map(e=>[e.id,e])))}catch(i){console.error("Failed to load routines:",i)}finally{a.value=!1}};console.debug("routines init scheduled"),h(async()=>{console.debug("routines init started");try{await n()}catch(i){console.error("routines init error",i)}console.debug("routines init finished")});const s=i=>t.value[i],l=i=>{t.value[i.id]=i},d=i=>{delete t.value[i]},u=(i,e)=>{Object.assign(t.value[i],e)};return{routines:t,loadRoutines:n,routinesLoading:a,get:s,add:l,remove:d,update:u,removeHabitFromRoutine:(i,e)=>{const o=s(i);o&&(o.habitInstances=o.habitInstances.filter(f=>f.habitId!==e),u(i,{habitInstances:o.habitInstances}))}}};function E(t){const a=`${Date.now()}-${Math.random().toString(36).substring(2,10)}`;return`${t}-${a}`}export{q as a,A as b,S as c,O as d,x as e,j as f,E as g,k as h,I as i,N as j,$ as k,F as l,T as r,b as u};
